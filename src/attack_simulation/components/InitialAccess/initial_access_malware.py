import random
from datetime import datetime, timedelta
import pandas as pd
import polars as pl
from faker import Faker
from tqdm import tqdm

from ..utils import (
    generate_device_file_events,
    generate_device_process_events,
    generate_inbound_network_events,
    generate_outbound_network_events,
    generate_device_events
)

class InitialAccessMalwareGenerator:
    def __init__(self, benign_data, victims, attacker, last_scan_time, config=None):
        self.fake = Faker()
        self.benign_data = benign_data
        self.last_scan_time = last_scan_time
        self.victims = victims
        self.attacker = attacker
        self.data = None
        self.compromised_accounts = []
        self.malware_times = {}
        self.config = config or {}
        # Load config section
        malware_cfg = (self.config.get('attacks', {}) or {}).get('initial_access', {}).get('initial_access_malware', {})
        # Common malware download paths
        self.download_paths = malware_cfg.get('download_paths', [
            "Downloads",
            "Documents",
            "AppData\\Local\\Temp",
            "AppData\\Roaming",
            "Desktop"
        ])
        # Common malware file names and extensions
        self.malware_files = malware_cfg.get('malware_files', [
            {"name": "document", "ext": ".doc"},
            {"name": "invoice", "ext": ".pdf"},
            {"name": "report", "ext": ".xls"},
            {"name": "update", "ext": ".exe"},
            {"name": "installer", "ext": ".msi"}
        ])
        self.download_time_minutes_min = malware_cfg.get('download_time_minutes_min', 0)
        self.download_time_minutes_max = malware_cfg.get('download_time_minutes_max', 30)
        self.c2_port_min = malware_cfg.get('c2_port_min', 8000)
        self.c2_port_max = malware_cfg.get('c2_port_max', 9000)
        self.file_creation_seconds_min = malware_cfg.get('file_creation_seconds_min', 1)
        self.file_creation_seconds_max = malware_cfg.get('file_creation_seconds_max', 5)
        self.process_creation_seconds_min = malware_cfg.get('process_creation_seconds_min', 6)
        self.process_creation_seconds_max = malware_cfg.get('process_creation_seconds_max', 10)
        self.device_event_seconds_min = malware_cfg.get('device_event_seconds_min', 1)
        self.device_event_seconds_max = malware_cfg.get('device_event_seconds_max', 5)
        self.c2_connection_seconds_min = malware_cfg.get('c2_connection_seconds_min', 10)
        self.c2_connection_seconds_max = malware_cfg.get('c2_connection_seconds_max', 30)
        self.timeline_c2_minutes_min = malware_cfg.get('timeline_c2_minutes_min', 5)
        self.timeline_c2_minutes_max = malware_cfg.get('timeline_c2_minutes_max', 15)
        self.file_number_digits = malware_cfg.get('file_number_digits', 4)
        self.mitigation_recommendations = malware_cfg.get('mitigation_recommendations', [
            "Isolate affected systems from the network",
            "Reset passwords for affected accounts",
            "Block identified malicious IP addresses and domains",
            "Collect and preserve evidence for forensic analysis",
            "Scan systems for additional malware",
            "Review and update endpoint protection rules",
            "Consider implementing application whitelisting"
        ])

    def generate_malware_transfer(self):
        data = {}
        device_process_events = []
        device_file_events = []
        network_events = []
        device_events_list = []
        
        # Attack start time
        attack_start_time = self.fake.date_time_between(
            start_date=self.last_scan_time,
            end_date=datetime.today()
        )

        available_victims = self.victims.height
        num_victims = max(1, min(int(available_victims * 0.5), 3, available_victims))
        selected_victims = self.victims.sample(n=num_victims)
        self.compromised_accounts = selected_victims.to_dicts()
        
        for victim in tqdm(self.compromised_accounts, desc="Generating malware transfer events"):
            # Get user's device
            user_devices = self.benign_data["device_info"].filter(
                pl.col("LoggedOnUsers").str.contains(victim["AccountUpn"])
            )
            
            if user_devices.height > 0:
                device_info = user_devices.sample(n=1).to_dicts()[0]
                
                # Generate download time
                download_time = attack_start_time + timedelta(minutes=random.randint(self.download_time_minutes_min, self.download_time_minutes_max))
                self.malware_times[victim["AccountUpn"]] = download_time
                
                # Select malware file details
                malware_file = random.choice(self.malware_files)
                download_path = random.choice(self.download_paths)
                file_name = f"{malware_file['name']}_{self.fake.random_number(digits=self.file_number_digits)}{malware_file['ext']}"
                full_path = f"C:\\Users\\{victim['AccountName']}\\{download_path}\\{file_name}"
                
                # Generate download network event
                download_network_event = generate_inbound_network_events(
                    identity_row=victim,
                    device_row=device_info,
                    timestamp=download_time,
                    fake=self.fake,
                    remote_ip=self.attacker["SenderIPv4"],
                    remote_url=self.attacker["PhishingURL"],
                    remote_port=random.randint(self.c2_port_min, self.c2_port_max)
                )
                network_events.append(download_network_event)
                
                # Generate file creation event
                file_event = generate_device_file_events(
                    identity_row=victim,
                    device_row=device_info,
                    timestamp=download_time + timedelta(seconds=random.randint(self.file_creation_seconds_min, self.file_creation_seconds_max)),
                    fake=self.fake,
                    file_name=file_name,
                    file_path=full_path
                )
                device_file_events.append(file_event)
                
                # Use the generated file details for process events
                file_name = file_event["FileName"]
                file_path = file_event["FolderPath"]
                
                # Generate process creation event
                process_event = generate_device_process_events(
                    identity_row=victim,
                    device_row=device_info,
                    timestamp=download_time + timedelta(seconds=random.randint(self.process_creation_seconds_min, self.process_creation_seconds_max)),
                    fake=self.fake,
                    file_name=file_name,
                    process_command_line=f"{file_path}\\{file_name}"
                )
                device_process_events.append(process_event)
                
                # Generate device event for file execution
                device_event = generate_device_events(
                    identity_row=victim,
                    device_row=device_info,
                    timestamp=download_time + timedelta(seconds=random.randint(self.device_event_seconds_min, self.device_event_seconds_max)),
                    fake=self.fake
                )
                device_events_list.append(device_event)
                
                # Generate C2 connection after execution
                c2_time = download_time + timedelta(seconds=random.randint(self.c2_connection_seconds_min, self.c2_connection_seconds_max))
                c2_network_event = generate_outbound_network_events(
                    identity_row=victim,
                    device_row=device_info,
                    timestamp=c2_time,
                    fake=self.fake,
                    remote_ip=self.attacker["ExternalServerIP"],
                    remote_url=self.attacker["ExternalServerName"],
                    remote_port=random.randint(self.c2_port_min, self.c2_port_max)
                )
                network_events.append(c2_network_event)
        
        # Combine all events into data dictionary
        if device_process_events:
            data["device_process_events"] = pl.DataFrame(device_process_events).sort("Timestamp")
        if device_file_events:
            data["device_file_events"] = pl.DataFrame(device_file_events).sort("Timestamp")
        if network_events:
            data["device_network_events"] = pl.DataFrame(network_events).sort("Timestamp")
        if device_events_list:
            data["device_events"] = pl.DataFrame(device_events_list).sort("Timestamp")
            
        self.data = data
        
        last_event_time = datetime.now()
        if network_events:
            last_event_time = max(event["Timestamp"] for event in network_events)

        return data, selected_victims, last_event_time

    def generate_question_answer_pairs(self):
        questions = []
        answers = []
        
        # Initial detection questions
        Q1 = "Is there evidence of malware download and execution in the environment?"
        Q1_answer = "Yes" if self.data.get("device_file_events", pl.DataFrame()).height > 0 else "No"
        questions.append(Q1)
        answers.append(Q1_answer)
        
        # Identify compromised accounts
        Q2 = "Which accounts appear to have downloaded and executed malware?"
        Q2_answer = [account["AccountUpn"] for account in self.compromised_accounts]
        questions.append(Q2)
        answers.append(Q2_answer)
        
        # Determine malware details
        Q3 = "What are the characteristics of the downloaded malware?"
        malware_details = []
        if "device_file_events" in self.data:
            files = self.data["device_file_events"]
            for file in files.to_dicts():
                malware_details.append({
                    "FileName": file["FileName"],
                    "FilePath": file["FolderPath"],
                    "FileSize": file["FileSize"],
                    "DownloadTime": file["Timestamp"]
                })
        Q3_answer = malware_details if malware_details else "No malware files detected"
        questions.append(Q3)
        answers.append(Q3_answer)
        
        # Network activity analysis
        Q4 = "What network activity is associated with the malware?"
        network_activity = []
        if "device_network_events" in self.data:
            network_events = self.data["device_network_events"]
            for event in network_events.to_dicts():
                network_activity.append({
                    "Time": event["Timestamp"],
                    "SourceIP": event["LocalIP"],
                    "DestinationIP": event["RemoteIP"],
                    "DestinationURL": event["RemoteUrl"],
                    "Port": event["RemotePort"]
                })
        Q4_answer = network_activity if network_activity else "No network activity detected"
        questions.append(Q4)
        answers.append(Q4_answer)
        
        # Process execution analysis
        Q5 = "What processes were executed as part of the malware activity?"
        process_details = []
        if "device_process_events" in self.data:
            processes = self.data["device_process_events"]
            for process in processes.to_dicts():
                process_details.append({
                    "Time": process["Timestamp"],
                    "ProcessName": process["FileName"],
                    "CommandLine": process["ProcessCommandLine"]
                })
        Q5_answer = process_details if process_details else "No suspicious processes detected"
        questions.append(Q5)
        answers.append(Q5_answer)
        
        # Timeline analysis
        Q6 = "What is the timeline of the malware activity?"
        timeline = {}
        for account in self.compromised_accounts:
            upn = account["AccountUpn"]
            if upn in self.malware_times:
                timeline[upn] = {
                    "DownloadTime": self.malware_times[upn].strftime("%Y-%m-%d %H:%M:%S"),
                    "FirstC2Time": (self.malware_times[upn] + timedelta(minutes=random.randint(self.timeline_c2_minutes_min, self.timeline_c2_minutes_max))).strftime("%Y-%m-%d %H:%M:%S")
                }
        Q6_answer = timeline
        questions.append(Q6)
        answers.append(Q6_answer)
        
        # Mitigation recommendations
        Q7 = "What immediate actions should be taken to respond to this malware incident?"
        Q7_answer = self.mitigation_recommendations
        questions.append(Q7)
        answers.append(Q7_answer)
        
        qa_df = pl.DataFrame({"Question": questions, "Answer": answers}, strict=False)
        return qa_df
