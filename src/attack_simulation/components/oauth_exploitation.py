# attacker_simulation.py  
  
import time  
import random  
import uuid  
  
class MockIdentityProvider:  
    """  
    A mock identity provider to simulate OAuth 2.0 Device Authorization Flow.  
    """  
  
    def __init__(self):  
        self.device_codes = {}  
        self.user_tokens = {}  
  
    def request_device_code(self, client_id, scope):  
        """  
        Simulate requesting a device code from the identity provider.  
        """  
        device_code = str(uuid.uuid4())  
        user_code = str(random.randint(100000, 999999))  
        verification_uri = "https://mockidp.com/device"  
        expires_in = 600  # seconds  
  
        self.device_codes[device_code] = {  
            'user_code': user_code,  
            'client_id': client_id,  
            'scope': scope,  
            'expires_in': expires_in,  
            'authorized': False,  
            'access_token': None,  
            'refresh_token': None  
        }  
  
        return {  
            'device_code': device_code,  
            'user_code': user_code,  
            'verification_uri': verification_uri,  
            'expires_in': expires_in,  
            'interval': 5  # polling interval in seconds  
        }  
  
    def authorize_device_code(self, user_code, user_id):  
        """  
        Simulate the user authorizing the device code.  
        """  
        for device_code, info in self.device_codes.items():  
            if info['user_code'] == user_code:  
                info['authorized'] = True  
                # Generate tokens  
                access_token = f"access_token_{uuid.uuid4()}"  
                refresh_token = f"refresh_token_{uuid.uuid4()}"  
                info['access_token'] = access_token  
                info['refresh_token'] = refresh_token  
                self.user_tokens[user_id] = {  
                    'access_token': access_token,  
                    'refresh_token': refresh_token,  
                    'scope': info['scope']  
                }  
                return True  
        return False  
  
    def poll_for_token(self, device_code):  
        """  
        Simulate the attacker polling for the token.  
        """  
        if device_code not in self.device_codes:  
            return {'error': 'invalid_device_code'}  
  
        info = self.device_codes[device_code]  
        if info['authorized']:  
            return {  
                'access_token': info['access_token'],  
                'refresh_token': info['refresh_token'],  
                'expires_in': 3600,  
                'token_type': 'Bearer',  
                'scope': info['scope']  
            }  
        else:  
            return {'error': 'authorization_pending'}  
  
class AttackerSimulation:  
    """  
    Simulates the attacker's logic to poll for tokens.  
    """  
  
    def __init__(self, identity_provider):  
        self.idp = identity_provider  
  
    def initiate_device_authorization(self, client_id, scope):  
        """  
        Begin the device authorization flow.  
        """  
        device_code_response = self.idp.request_device_code(client_id, scope)  
        self.device_code = device_code_response['device_code']  
        self.user_code = device_code_response['user_code']  
        self.verification_uri = device_code_response['verification_uri']  
        self.interval = device_code_response['interval']  
        print("Device code obtained. Prompting user to authenticate...")  
        print(f"User code: {self.user_code}")  
        print(f"Please visit {self.verification_uri} and enter the user code.")  
        return device_code_response  
  
    def poll_for_tokens(self):  
        """  
        Poll the identity provider for tokens.  
        """  
        print("Polling for tokens...")  
        max_polls = 60  # Max number of polls before timeout  
        for _ in range(max_polls):  
            token_response = self.idp.poll_for_token(self.device_code)  
            if 'error' in token_response:  
                if token_response['error'] == 'authorization_pending':  
                    print("Authorization pending. Waiting...")  
                    time.sleep(self.interval)  
                else:  
                    print(f"Error: {token_response['error']}")  
                    break  
            else:  
                print("Tokens received!")  
                self.access_token = token_response['access_token']  
                self.refresh_token = token_response['refresh_token']  
                print(f"Access Token: {self.access_token}")  
                print(f"Refresh Token: {self.refresh_token}")  
                return token_response  
        else:  
            print("Polling timed out without receiving tokens.")  
            return None  
  
# Simulation of the environment  
def main():  
    # Initialize the mock identity provider  
    idp = MockIdentityProvider()  
  
    # Initialize the attacker simulation  
    attacker = AttackerSimulation(idp)  
  
    # Attacker initiates device authorization  
    client_id = 'mock_client_id'  
    scope = 'https://mockapi.com/.default'  
    device_code_info = attacker.initiate_device_authorization(client_id, scope)  
  
    # Simulate the user's action (this would normally be done by the user)  
    user_id = 'user123'  
    user_enters_code = input("Simulate user entering code? (yes/no): ")  
    if user_enters_code.lower() == 'yes':  
        user_code = device_code_info['user_code']  
        # User authorizes the device code  
        idp.authorize_device_code(user_code, user_id)  
        print("User has authorized the device code.")  
  
    # Attacker polls for tokens  
    tokens = attacker.poll_for_tokens()  
    if tokens:  
        # Attacker can now attempt to access protected resources using the access token  
        print("Attacker can now use the access token to access resources (simulation).")  
    else:  
        print("Attacker failed to obtain tokens.")  
  
if __name__ == "__main__":  
    main()